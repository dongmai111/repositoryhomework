#include "MyLinkedList.cpp"
#include <iostream>

using namespace std;

int main()
{
    MyLinkedList<int> testList;
    int number;
    char letter;
    do
    {
        // Ask the user to enter an item
        cout<<"Enter an item to the list"<<endl;
        cin >> number;
        testList.insertItem(number);

        // Ask the user if he/she wants to enter more item
        cout<<"Press any letter to continue and n to end"<<endl;
        cin>>letter;

    }while(letter != 'n');


        cout<<"\n\nEnter a number to search"<<endl;
        int look;
        cin>>look;

        // To search a given item
        cout<<"The item you're looking for is ";
        if(testList.searchItem(look)== true)
            cout<<"in the list"<<endl;

        else
            cout<<"not in the list"<<endl;

        // To return if the list if empty or not
        if(testList.isEmpty()== true)
            cout<<"\n\nThe list is empty"<<endl;

        else
            cout<<"\n\nThe list is not empty"<<endl;

        //To return if the list is full
        if(testList.isFull ()== true)
            cout<<"\n\nThe list is full"<<endl;

        else
            cout<<"\n\nThe list is not full"<<endl;

        // To return the length of the list
        cout<<"\n\nThe length of the list is " <<testList.getLength()<<endl;



        // To delete a given item
        cout<<"\n\nEnter a number to delete"<<endl;
        int takeout;
        cin>>takeout;
        if(testList.deleteItem(takeout) == true)
            cout<<"\nItem found, "<<takeout<<" it's being deleted"<<endl;

        else
             cout<<"\nNothing to delete - The list is empty"<<endl;



        cout<<"\n\nEnter a number to delete all occurences item"<<endl;
        int occurences;
        cin>>occurences;

        // If its true then the item is already deleted
        if(testList.deleteOccurencesItem(occurences) == true)
            cout<<"\nDeleteOccurences method is called, all the duplicates of "<<occurences<<" is deleted from the list"<<endl;

        // The item can't find it in the list
        else
            cout<<"\nThe duplicate of a number you want to delete is not in the list"<<endl;


        // To check if the list is empty now
        cout<<"\n\nNow the make empty method is called"<<endl;
        testList.makeEmpty();



}

//#endif



#ifndef MYLINKEDLIST_H
#define MYLINKEDLIST_H

#include <iostream>

using namespace std;

template <class xtype>
struct node
{
    xtype info;
    node<xtype> *next;
    node<xtype> *prev;

};

template <class xtype>
class MyLinkedList
{
    public:
        //friend ostream& operator<<(ostream &ofile, MyLinkedList other);
        MyLinkedList();             // Constructor
        //~MyLinkedList();            // Destructor, use to detroy the list
  // !!     MyLinkedList(const MyLinkedList& other);            // copy constructor
  //  !!    MyLinkedList operator = (const MyLinkedList& other);         // to overload = operator
      bool deleteItem (xtype);         // to delete a given item
      void insertItem (xtype);         // to insert a given item
      bool isFull ();         // to check if its full
     bool isEmpty ();        // to check if its empty
      void makeEmpty ();          // to make empty
        int getLength ();          // to return the length of the list
        bool searchItem (xtype);         // to search a given item
       bool deleteOccurencesItem (xtype);           // to delete all occurences  of an item

    private:
        node<xtype> *head;
        int length;

};

#endif // MYLINKEDLIST_H



#include "MyLinkedList.h"
#include <iostream>
using namespace std;

template <class xtype>
MyLinkedList<xtype>::MyLinkedList()
{
    head = NULL;                                    // Put the list to empty
    length=0;                                        // Put length to 0

}

/*
template <class xtype>
MyLinkedList<xtype>::~MyLinkedList()
{
    makeEmpty ();
}



template <class xtype>
MyLinkedList<xtype>::MyLinkedList(const MyLinkedList& other)
{

}

template <class xtype>
MyLinkedList MyLinkedList<xtype>::operator = (const MyLinkedList &other)
{
    if ()
        return
}


*/
template <class xtype>
bool MyLinkedList<xtype>::deleteItem (xtype item)
{
     //In case the list is empty
    if (head == NULL)
        return false;

        // save head to temp
        node <xtype> *temp = head;
        // save the perious node to s
        node <xtype> *s=temp->prev;

      // delete the node if and only if there's only one node in the list
    if (temp->info == item && temp == temp->next)
    {
        delete temp;
        temp=NULL;
        return true;
    }

        // If the item is in the first node
    else if (head->info == item)
    {
        head=s;
        head->next=temp->next;
        temp->next->prev=head;
        delete temp;
        return true;
    }

    else
    {
         // save q to the next node
        node<xtype> *q=temp->next;

        while(q != NULL && item >= q->info)
        {
            if (q->info == item)
            {
                q->next->prev=temp;
                temp->next=q->next;
                delete q;
                return true;
            }

            else
            {
                temp=q;
                q=q->next;
            }

        }

        return false;
    }


}


template <class xtype>
void MyLinkedList<xtype>::insertItem (xtype item)
{
    node<xtype> *p;
    node<xtype> *s;
    node<xtype> *temp = new node<xtype>;
    temp->info = item;

    // If head is empty, make everything into NULL
    if (head == NULL)
    {
        head = temp;
        head->next = head->prev = NULL;
    }

    else
    {
        p=head;
        while (p != NULL && item > p->info)
        {
            s = p;
            p = p->next;
        }

        if (p==head)
        {
            head->prev=temp;
            temp->next=head;
            temp->prev=NULL;
            head=temp;
        }

        else
        {
            s->next=temp;
            temp->prev=s;
            temp->next=p;

            if (p != NULL)
                p->prev=temp;
        }
    }

     // Increase length by one when temp->next is not equal to NULL
    length++;
}



template <class xtype>
bool MyLinkedList<xtype>::isFull ()
{
    // Check to see if it's full or not
    if(!isEmpty ())
        return true;

    else
        return false;

}

template <class xtype>
bool MyLinkedList<xtype>::isEmpty ()
{
    // Check to see if it's empty
    return head == NULL;
}


template <class xtype>
void MyLinkedList<xtype>::makeEmpty ()
{
    node<xtype> *temp=head;

     // If there's one node
    if (temp == temp->next->prev)
    {
        delete temp;
        temp=NULL;
    }
    else
    {
        node<xtype> *p=temp->prev;
        node<xtype> *q=temp->next;
        while (temp!=NULL)
        {
            p->next=q;
            q->prev=p;
            delete temp;
            temp=q;
        }
    }


    temp=NULL;

    if(temp==NULL)
        cout<<"The list is now empty"<<endl;

    else
        cout<<"The list is still not empty"<<endl;


}



template <class xtype>
int MyLinkedList<xtype>::getLength ()
{
    // return length after the head->next is equal to null
   return length;
}

template <class xtype>
bool MyLinkedList<xtype>::searchItem (xtype item)
{
    // Item can't find it if the list is empty or the item is lesser than the first item
    if (head == NULL || head->info > item)
        return false;

    else
    {
        //
       while (head != NULL && head-> info <= item)
        {
            if (head->info == item)
                return true;


             else
                head=head->next;          // go to the next value
        }

        return false;                       // can't find the given item after seaching

    }

}

template <class xtype>
bool MyLinkedList<xtype>::deleteOccurencesItem (xtype item)
{
    int counting=0;

    // return false, if head is NULL
    if (head == NULL)
        return false;

        node <xtype> *temp = head;
        node <xtype> *s=temp->prev;

     // Check to see if the list has only one node
    if (temp->info == item && temp == temp->next)
    {
        delete temp;
        temp=NULL;
        return true;
    }

     // Check to see if the first node is the item the user wants to delete
    else if (head->info == item)
    {
        head=s;
        head->next=temp->next;
        temp->next->prev=head;
        delete temp;
        return true;
    }

    else
    {
         // save q to the next node
        node<xtype> *q=temp->next;

        while(q != NULL && item >= q->info)
        {
            if (q->info == item)
            {
                q->next->prev=temp;
                temp->next=q->next;
                delete q;

                //if one node is being deleted, secrease count
                counting--;
            }

            else
            {
                temp=q;
                q=q->next;
            }

        }

        // if count is decreased, some nodes are deleted
        if(counting < 0)
            return true;

        else
            return false;
    }


}
